{
  "version": 3,
  "sources": ["../../react-broadcast-sync/src/utils/messageUtils.ts", "../../react-broadcast-sync/src/utils/debug.ts", "../../react-broadcast-sync/src/hooks/useBroadcastChannel.ts", "../../react-broadcast-sync/src/BroadcastProvider.tsx"],
  "sourcesContent": ["import { InternalMessage } from '../types/types';\n\nconst INTERNAL_PREFIX = '__INTERNAL__';\nconst SECRET = 'react-broadcast-sync';\n\n// Generate a random 9-character alphanumeric string\nexport const generateRandomPart = () => Math.random().toString(36).substr(2, 9);\n\n// Generate a unique source name for a tab\nexport const generateSourceName = () => `tab-${generateRandomPart()}`;\n\n// Generate a unique message ID\nexport const generateMessageId = (source: string, timestamp: number) => {\n  const raw = `${generateRandomPart()}-${source}-${timestamp}`;\n  return btoa(raw).replace(/=+$/, '');\n};\n\n// Check if a message is valid\nexport const isValidMessage = (message: any): boolean => {\n  return Boolean(message && typeof message === 'object' && 'id' in message);\n};\n\n// Check if a message has expired\nexport const isMessageExpired = (message: { expirationDate?: number }): boolean => {\n  return message.expirationDate ? message.expirationDate < Date.now() : false;\n};\n\n// Create a new message object\nexport const createMessage = (\n  type: string,\n  content: any,\n  source: string,\n  options: { expirationDate?: number; expirationDuration?: number } = {}\n): any => {\n  const timestamp = Date.now();\n  return {\n    id: generateMessageId(source, timestamp),\n    type,\n    message: content,\n    timestamp,\n    source,\n    expirationDate:\n      options.expirationDate ??\n      (options.expirationDuration ? timestamp + options.expirationDuration : undefined),\n  };\n};\n\nexport const getInternalMessageType = (\n  baseType: InternalMessage,\n  channelName: string,\n  namespace = ''\n): string => {\n  const fullChannel = `${channelName}-${namespace}`;\n  const input = `${SECRET}:${baseType}:${fullChannel}`;\n  const hash = btoa(input); // optional: use sha256 if added\n  return `${INTERNAL_PREFIX}:${baseType}:${hash}`;\n};\n\nexport const isInternalType = (type: string): boolean => {\n  return type.startsWith(`${INTERNAL_PREFIX}:`);\n};\n\nexport const isValidInternalClearMessage = (message: any): boolean => {\n  return (\n    message &&\n    typeof message === 'object' &&\n    typeof message.type === 'string' &&\n    isInternalType(message.type) &&\n    typeof message.source === 'string'\n  );\n};\n\nexport const debounce = <T extends (...args: any[]) => any>(\n  fn: T,\n  wait: number\n): ((...args: Parameters<T>) => void) & {\n  cancel: () => void;\n  flush: () => ReturnType<T> | undefined;\n} => {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: Parameters<T> | null = null;\n  let result: ReturnType<T> | undefined;\n\n  const debounced = (...args: Parameters<T>) => {\n    lastArgs = args;\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      if (lastArgs !== null) {\n        result = fn(...lastArgs);\n        lastArgs = null;\n      }\n    }, wait);\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n      lastArgs = null;\n    }\n  };\n\n  debounced.flush = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n      if (lastArgs !== null) {\n        result = fn(...lastArgs);\n        lastArgs = null;\n      }\n    }\n    return result;\n  };\n\n  return debounced as typeof debounced & {\n    cancel: () => void;\n    flush: () => ReturnType<T> | undefined;\n  };\n};\n", "declare const process: { env: { [key: string]: string | undefined } };\n\nconst isDebugMode = () => {\n  if (typeof process !== 'undefined' && process.env) {\n    return process.env.REACT_APP_DEBUG_BROADCAST === 'true';\n  }\n  return false;\n};\n\ntype LogLevel = 'info' | 'warn' | 'error';\n\nconst log = (level: LogLevel, message: string, data?: any) => {\n  if (!isDebugMode()) return;\n\n  const timestamp = new Date().toISOString();\n  const prefix = `[${timestamp}] [react-broadcast-sync]`;\n  switch (level) {\n    case 'info':\n      console.log(prefix, message, data || '');\n      break;\n    case 'warn':\n      console.warn(prefix, message, data || '');\n      break;\n    case 'error':\n      console.error(prefix, message, data || '');\n      break;\n  }\n};\n\nexport const debug = {\n  channel: {\n    created: (name: string) => log('info', 'Channel created:', name),\n    closed: (name: string) => log('info', 'Channel closed:', name),\n  },\n  message: {\n    sent: (message: any) => log('info', 'Message sent:', message),\n    received: (message: any) => log('info', 'Message received:', message),\n    cleared: (messageId: string) => log('info', 'Message cleared:', messageId),\n    expired: (messageId: string) => log('info', 'Message expired:', messageId),\n    duplicate: (messageId: string) => log('warn', 'Duplicate message ignored:', messageId),\n    allSentCleared: () => log('info', 'All sent messages cleared'),\n    allReceivedCleared: () => log('info', 'All received messages cleared'),\n    ignored: (messageType: string) =>\n      log('info', 'Message ignored due to type filter:', messageType),\n  },\n  ping: {\n    inProgress: () => log('warn', 'Ping already in progress. Skipping call.'),\n  },\n  cleanup: {\n    started: () => log('info', 'Cleanup started'),\n    completed: (removedCount: number) => log('info', 'Cleanup completed:', removedCount),\n  },\n  error: (context: {\n    action: string;\n    channelName?: string;\n    type?: string;\n    source?: string;\n    originalError?: unknown;\n  }) => {\n    const { action, channelName, type, source, originalError } = context;\n\n    let message = `${action}`;\n    if (channelName) message += ` | channel: ${channelName}`;\n    if (type) message += ` | type: ${type}`;\n    if (source) message += ` | source: ${source}`;\n    if (originalError instanceof Error) {\n      message += ` | cause: ${originalError.message}`;\n    } else if (typeof originalError === 'string') {\n      message += ` | cause: ${originalError}`;\n    } else if (originalError != null) {\n      try {\n        message += ` | cause: ${JSON.stringify(originalError)}`;\n      } catch {\n        message += ' | cause: [unserializable]';\n      }\n    }\n\n    log('error', 'Error:', message);\n  },\n};\n", "import { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport {\n  BroadcastActions,\n  BroadcastMessage,\n  BroadcastOptions,\n  ClearReceivedMessagesOptions,\n  ClearSentMessagesOptions,\n  GetLatestMessageOptions,\n  InternalMessage,\n  SendMessageOptions,\n} from '../types/types';\nimport {\n  generateSourceName,\n  isValidMessage,\n  isMessageExpired,\n  createMessage,\n  getInternalMessageType,\n  isValidInternalClearMessage,\n  debounce,\n} from '../utils/messageUtils';\nimport { debug } from '../utils/debug';\n\nconst INTERNAL_MESSAGE_TYPES: Record<string, InternalMessage> = {\n  CLEAR_SENT_MESSAGES: 'CLEAR_SENT_MESSAGES',\n  PING: 'PING',\n  PONG: 'PONG',\n} as const;\n\nlet flushSyncFn: undefined | ((cb: () => void) => void) = undefined;\nif (process.env.NODE_ENV === 'test') {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    flushSyncFn = require('react-dom').flushSync;\n  } catch {\n    // ignore error in test env\n  }\n}\n\n/**\n * useBroadcastChannel hook\n *\n * Note: When batching is enabled (batchingDelayMs > 0), messages sent over the channel may be received as either:\n *   - a single BroadcastMessage (object), or\n *   - an array of BroadcastMessage (batch)\n *\n * The event handler in this hook supports both formats. If you listen to the channel directly, always check:\n *   if (Array.isArray(event.data)) { ... } else { ... }\n */\nexport const useBroadcastChannel = (\n  channelName: string,\n  options: BroadcastOptions = {}\n): BroadcastActions => {\n  const {\n    sourceName,\n    cleaningInterval = 1000,\n    keepLatestMessage = false,\n    registeredTypes = [],\n    namespace = '',\n    deduplicationTTL = 5 * 60 * 1000,\n    cleanupDebounceMs = 0,\n    batchingDelayMs = 20,\n    excludedBatchMessageTypes = [],\n  } = options;\n\n  // State\n  const [messages, setMessages] = useState<BroadcastMessage[]>([]);\n  const [sentMessages, setSentMessages] = useState<BroadcastMessage[]>([]);\n  const [error, setError] = useState<string | null>(null);\n  const [isPingInProgress, setIsPingInProgress] = useState(false);\n\n  // Refs\n  const channel = useRef<BroadcastChannel | null>(null);\n  const receivedMessageIds = useRef(new Map<string, number>());\n  const activeSourcesCollector = useRef<Set<string> | null>(null);\n  const batchingTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const batchingMessagesRef = useRef<BroadcastMessage[]>([]);\n  const batchingErrorRef = useRef(false);\n\n  // Memoized values\n  const source = useMemo(() => sourceName || generateSourceName(), [sourceName]);\n  const internalTypes = useMemo(\n    () => ({\n      CLEAR_SENT_MESSAGES: getInternalMessageType(\n        INTERNAL_MESSAGE_TYPES.CLEAR_SENT_MESSAGES,\n        channelName,\n        namespace\n      ),\n      PING: getInternalMessageType(INTERNAL_MESSAGE_TYPES.PING, channelName, namespace),\n      PONG: getInternalMessageType(INTERNAL_MESSAGE_TYPES.PONG, channelName, namespace),\n    }),\n    [channelName, namespace]\n  );\n\n  const resolvedChannelName = useMemo(() => {\n    // Only append dash if namespace is non-empty\n    return namespace ? `${channelName}-${namespace}` : channelName;\n  }, [channelName, namespace]);\n\n  const stableRegisteredTypes = useMemo(() => registeredTypes, [JSON.stringify(registeredTypes)]);\n\n  const performCleanup = useCallback(() => {\n    setMessages(prev => prev.filter(msg => !isMessageExpired(msg)));\n  }, []);\n\n  const debouncedCleanup = useRef<{\n    (...args: Parameters<typeof performCleanup>): void;\n    cancel: () => void;\n  }>(\n    cleanupDebounceMs > 0\n      ? debounce(performCleanup, cleanupDebounceMs)\n      : Object.assign(performCleanup, { cancel: () => {} })\n  ).current;\n\n  const setErrorMessage = useCallback((error: string) => {\n    setError(error);\n    setTimeout(() => setError(null), 3000);\n  }, []);\n\n  const ping = useCallback(\n    (timeoutMs: number = 300): Promise<string[]> => {\n      if (isPingInProgress) {\n        debug.ping.inProgress();\n        return Promise.resolve([]);\n      }\n\n      if (!channel.current) {\n        const error =\n          'BroadcastChannel is not supported in this browser. Please check browser compatibility.';\n        debug.error({\n          action: 'ping',\n          channelName: resolvedChannelName,\n          originalError: error,\n        });\n        setErrorMessage(error);\n        return Promise.resolve([]);\n      }\n\n      // Set synchronously before returning the promise\n      if (flushSyncFn) {\n        flushSyncFn(() => setIsPingInProgress(true));\n      } else {\n        setIsPingInProgress(true);\n      }\n      const collector = new Set<string>();\n      activeSourcesCollector.current = collector;\n\n      channel.current.postMessage(createMessage(internalTypes.PING, null, source));\n\n      return new Promise(resolve => {\n        setTimeout(() => {\n          setIsPingInProgress(false);\n          if (activeSourcesCollector.current === collector) {\n            activeSourcesCollector.current = null;\n          }\n          resolve(Array.from(collector));\n        }, timeoutMs);\n      });\n    },\n    [internalTypes.PING, source, setErrorMessage, isPingInProgress, flushSyncFn]\n  );\n\n  const postMessage = useCallback(\n    (messageType: string, messageContent: any, options: SendMessageOptions = {}) => {\n      const channelCurrent = channel.current;\n      if (!channelCurrent) {\n        const error =\n          'BroadcastChannel is not supported in this browser. Please check browser compatibility.';\n        debug.error({\n          action: 'postMessage',\n          channelName: resolvedChannelName,\n          type: messageType,\n          originalError: error,\n        });\n        setErrorMessage(error);\n        return;\n      }\n\n      const message = createMessage(messageType, messageContent, source, options);\n      // Only batch if batchingDelayMs > 0 and messageType is not excluded\n      const shouldSendImmediately =\n        !batchingDelayMs || batchingDelayMs < 0 || excludedBatchMessageTypes.includes(messageType);\n      if (shouldSendImmediately) {\n        try {\n          channelCurrent.postMessage(message);\n        } catch (e) {\n          const error = 'Failed to send message';\n          debug.error({\n            action: 'postMessage',\n            channelName: resolvedChannelName,\n            type: messageType,\n            originalError: error,\n          });\n          setErrorMessage(error);\n          batchingErrorRef.current = true;\n        }\n      } else {\n        batchingMessagesRef.current.push(message);\n        if (!batchingTimeoutRef.current) {\n          batchingTimeoutRef.current = setTimeout(() => {\n            if (batchingErrorRef.current) {\n              batchingMessagesRef.current = [];\n              batchingTimeoutRef.current = null;\n              return;\n            }\n            try {\n              channelCurrent.postMessage(batchingMessagesRef.current);\n            } catch (e) {\n              const error = 'Failed to send message';\n              debug.error({\n                action: 'postMessage',\n                channelName: resolvedChannelName,\n                type: messageType,\n                originalError: error,\n              });\n              setErrorMessage(error);\n              batchingErrorRef.current = true;\n            }\n            batchingMessagesRef.current = [];\n            batchingTimeoutRef.current = null;\n          }, batchingDelayMs);\n        }\n      }\n      debug.message.sent(message);\n      setSentMessages(prev => [...prev, message]);\n    },\n    [source, setErrorMessage, batchingDelayMs, excludedBatchMessageTypes]\n  );\n\n  const clearReceivedMessages = useCallback((options: ClearReceivedMessagesOptions = {}) => {\n    const hasFilters = Boolean(\n      (options.ids && options.ids.length) ||\n        (options.types && options.types.length) ||\n        (options.sources && options.sources.length)\n    );\n\n    setMessages(prev =>\n      hasFilters\n        ? prev.filter(\n            msg =>\n              !(options.ids && options.ids.includes(msg.id)) &&\n              !(options.types && options.types.includes(msg.type)) &&\n              !(options.sources && options.sources.includes(msg.source))\n          )\n        : []\n    );\n    if (!hasFilters) {\n      debug.message.allReceivedCleared();\n    }\n  }, []);\n\n  const clearSentMessages = useCallback((options: ClearSentMessagesOptions = {}) => {\n    const { ids = [], types = [], sync = false } = options ?? {};\n    setSentMessages(prev =>\n      ids.length > 0 || types.length > 0\n        ? prev.filter(msg => {\n            // Only consider messages from the same sender\n            if (msg.source !== source) return true;\n\n            // Decide whether this message should be cleared:\n            // - If the ids array is empty, treat as wildcard (match all ids)\n            // - If the types array is empty, treat as wildcard (match all types)\n            const idMatches = ids.length === 0 || ids.includes(msg.id);\n            const typeMatches = types.length === 0 || types.includes(msg.type);\n\n            // Remove when BOTH criteria match (wildcards included)\n            return !(idMatches && typeMatches);\n          })\n        : []\n    );\n    if (ids.length === 0 && types.length === 0) {\n      debug.message.allSentCleared();\n    }\n    if (sync) {\n      channel.current?.postMessage(\n        createMessage(\n          internalTypes.CLEAR_SENT_MESSAGES,\n          { ids: options.ids ?? [], types: options.types ?? [] },\n          source\n        )\n      );\n    }\n  }, []);\n\n  const getLatestMessage = useCallback(\n    (options: GetLatestMessageOptions = {}) => {\n      const { source, type } = options;\n\n      for (let i = messages.length - 1; i >= 0; i--) {\n        const msg = messages[i];\n        const sourceMatches = !source || msg.source === source;\n        const typeMatches = !type || msg.type === type;\n        if (sourceMatches && typeMatches) {\n          return msg;\n        }\n      }\n\n      return null;\n    },\n    [messages]\n  );\n\n  const handleMessage = useCallback(\n    (event: MessageEvent) => {\n      try {\n        const message: BroadcastMessage = event.data;\n        debug.message.received(message);\n\n        if (!isValidMessage(message)) return;\n        if (message.source === source) return;\n        if (isValidInternalClearMessage(message)) {\n          if (message.type === internalTypes.CLEAR_SENT_MESSAGES) {\n            const { ids = [], types = [] } = (message as any).message || {};\n\n            setMessages(prev => [\n              ...prev.filter(msg => {\n                // Only consider messages from the same sender\n                if (msg.source !== message.source) return true;\n\n                // Decide whether this message should be cleared:\n                // - If the ids array is empty, treat as wildcard (match all ids)\n                // - If the types array is empty, treat as wildcard (match all types)\n                const idMatches = ids.length === 0 || ids.includes(msg.id);\n                const typeMatches = types.length === 0 || types.includes(msg.type);\n\n                return !(idMatches && typeMatches);\n              }),\n            ]);\n\n            return;\n          }\n          if (message.type === internalTypes.PING) {\n            channel.current?.postMessage(createMessage(internalTypes.PONG, null, source));\n            return;\n          }\n\n          if (message.type === internalTypes.PONG) {\n            const pongSource = message.source;\n            const collector = activeSourcesCollector.current;\n\n            if (collector && collector.has(pongSource) === false) {\n              collector.add(pongSource);\n            }\n\n            return;\n          }\n        }\n        if (stableRegisteredTypes.length > 0 && !stableRegisteredTypes.includes(message.type)) {\n          debug.message.ignored(message.type);\n          return;\n        }\n        if (isMessageExpired(message)) {\n          debug.message.expired(message.id);\n          return;\n        }\n\n        const now = Date.now();\n        const receivedAt = receivedMessageIds.current.get(message.id);\n        if (receivedAt && now - receivedAt < deduplicationTTL) {\n          debug.message.duplicate(message.id);\n          return;\n        }\n\n        receivedMessageIds.current.set(message.id, now);\n        setMessages(prev => (keepLatestMessage ? [message] : [...prev, message]));\n      } catch (e) {\n        const error = 'Error processing broadcast message';\n        debug.error({\n          action: 'handleMessage',\n          channelName: resolvedChannelName,\n          originalError: error,\n        });\n        setErrorMessage(error);\n      }\n    },\n    [\n      source,\n      stableRegisteredTypes,\n      keepLatestMessage,\n      setErrorMessage,\n      internalTypes,\n      deduplicationTTL,\n    ]\n  );\n\n  const closeChannel = useCallback(() => {\n    const bc = channel.current;\n    if (bc && typeof bc.close === 'function') {\n      bc.removeEventListener('message', handleMessage);\n      bc.close();\n      debug.channel.closed(resolvedChannelName);\n      channel.current = null;\n    }\n  }, [handleMessage, resolvedChannelName]);\n\n  useEffect(() => {\n    if (typeof BroadcastChannel === 'undefined') {\n      const error =\n        'BroadcastChannel is not supported in this browser. Please check browser compatibility.';\n      debug.error({\n        action: 'useBroadcastChannel',\n        channelName: resolvedChannelName,\n        originalError: error,\n      });\n      setErrorMessage(error);\n      return;\n    }\n\n    let bc: BroadcastChannel | null = null;\n    try {\n      bc = new BroadcastChannel(resolvedChannelName);\n    } catch (e) {\n      const error = 'Failed to create BroadcastChannel';\n      debug.error({\n        action: 'useBroadcastChannel',\n        channelName: resolvedChannelName,\n        originalError: e instanceof Error ? e : String(e),\n      });\n      setErrorMessage(error);\n      return;\n    }\n    channel.current = bc;\n    debug.channel.created(resolvedChannelName);\n\n    bc.addEventListener('message', (event: MessageEvent) => {\n      // event.data may be a single message or an array of messages (batch)\n      if (Array.isArray(event.data)) {\n        event.data.forEach((message: BroadcastMessage) => {\n          handleMessage({ data: message } as MessageEvent<BroadcastMessage>);\n        });\n      } else {\n        handleMessage(event);\n      }\n    });\n    return () => {\n      closeChannel();\n    };\n  }, [resolvedChannelName, handleMessage, setErrorMessage]);\n\n  useEffect(() => {\n    if (cleaningInterval <= 0) return;\n\n    const interval = setInterval(() => {\n      debug.cleanup.started();\n      const before = messages.length;\n      debouncedCleanup();\n      debug.cleanup.completed(before - messages.length);\n    }, cleaningInterval);\n\n    return () => {\n      clearInterval(interval);\n      // Cancel any pending debounced cleanup on unmount\n      if (cleanupDebounceMs > 0) {\n        debouncedCleanup.cancel?.();\n      }\n    };\n  }, [cleaningInterval, debouncedCleanup, cleanupDebounceMs]);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      const now = Date.now();\n      for (const [key, timestamp] of receivedMessageIds.current.entries()) {\n        if (now - timestamp >= deduplicationTTL) {\n          receivedMessageIds.current.delete(key);\n        }\n      }\n    }, 60 * 1000);\n\n    return () => clearInterval(interval);\n  }, [deduplicationTTL]);\n\n  useEffect(() => {\n    return () => {\n      // Always flush any unsent batched messages on unmount\n      if (batchingMessagesRef.current.length > 0 && channel.current && !batchingErrorRef.current) {\n        try {\n          channel.current.postMessage(batchingMessagesRef.current);\n        } catch (e) {\n          const error = 'Failed to send message';\n          debug.error({\n            action: 'useBroadcastChannel',\n            channelName: resolvedChannelName,\n            originalError: e instanceof Error ? e : String(e),\n          });\n          setErrorMessage(error);\n        }\n        batchingMessagesRef.current = [];\n        // Allow event loop to process delivery for tests\n        setTimeout(() => {}, 0);\n      }\n      if (batchingTimeoutRef.current) {\n        clearTimeout(batchingTimeoutRef.current);\n        batchingTimeoutRef.current = null;\n      }\n      batchingErrorRef.current = false;\n    };\n  }, []);\n\n  return {\n    channelName: resolvedChannelName,\n    messages,\n    sentMessages,\n    isPingInProgress,\n    ping,\n    postMessage,\n    clearReceivedMessages,\n    clearSentMessages,\n    getLatestMessage,\n    error,\n    closeChannel,\n  };\n};\n\nexport default useBroadcastChannel;\n", "import React, { createContext, useContext } from 'react';\nimport { useBroadcastChannel } from './hooks/useBroadcastChannel';\nimport { BroadcastActions } from './types/types';\n\nconst BroadcastChannelContext = createContext<BroadcastActions | undefined>(undefined);\n\ninterface BroadcastProviderProps {\n  channelName: string;\n  children: React.ReactNode;\n}\n\nexport const BroadcastProvider: React.FC<BroadcastProviderProps> = ({ children, channelName }) => {\n  const BroadcastChannelActions = useBroadcastChannel(channelName);\n\n  return (\n    <BroadcastChannelContext.Provider value={BroadcastChannelActions}>\n      {children}\n    </BroadcastChannelContext.Provider>\n  );\n};\n\nexport const useBroadcastProvider = (): BroadcastActions => {\n  const context = useContext(BroadcastChannelContext);\n  if (!context) {\n    throw new Error('useBroadcastProvider must be used within a BroadcastProvider');\n  }\n  return context;\n};\n"],
  "mappings": ";;;;;;;;;;;AAEA,IAAMA,IAAkB;AAAxB,IAIaC,IAAqBA,MAAMC,KAAKC,OAAAA,EAASC,SAAS,EAAA,EAAIC,OAAO,GAAG,CAAA;AAJ7E,IAUaC,IAAoBA,CAACC,IAAgBC,OAAAA;AAChD,QAAMC,KAAM,GAAGR,EAAAA,CAAAA,IAAwBM,EAAAA,IAAUC,EAAAA;AACjD,SAAOE,KAAKD,EAAAA,EAAKE,QAAQ,OAAO,EAAA;AAAA;AAZlC,IAqBaC,IAAoBC,CAAAA,OAAAA,CAAAA,CACxBA,GAAQC,kBAAiBD,GAAQC,iBAAiBC,KAAKC,IAAAA;AAtBhE,IA0BaC,IAAgBA,CAC3BC,IACAC,IACAZ,IACAa,KAAoE,CAAA,MAAA;AAAA,MAAAC;AAEpE,QAAMb,KAAYO,KAAKC,IAAAA;AACvB,SAAO,EACLM,IAAIhB,EAAkBC,IAAQC,EAAAA,GAC9BU,MAAAA,IACAL,SAASM,IACTX,WAAAA,IACAD,QAAAA,IACAO,gBAEE,UAAAO,KADAD,GAAQN,mBAAAA,WACRS,KAAAA,KAACH,GAAQI,qBAAqBhB,KAAYY,GAAQI,qBAAAA,OAAqBC;AAAAA;AAzC7E,IA6CaC,IAAyBA,CACpCC,IACAC,IACAC,KAAY,OAAA;AAEZ,QAEMC,KAAOpB,KADC,wBAAaiB,EAAAA,IADP,GAAGC,EAAAA,IAAeC,EAAAA,EAAAA,EAAAA;AAGtC,SAAO,GAAG7B,CAAAA,IAAmB2B,EAAAA,IAAYG,EAAAA;AAAAA;AArD3C,IA4DaC,IAA+BlB,CAAAA,OAExCA,MACmB,YAAA,OAAZA,MACiB,YAAA,OAAjBA,GAAQK,QACAL,GAAQK,KARbc,WAAW,GAAGhC,CAAAA,GAAAA,KASE,YAAA,OAAnBa,GAAQN;AAlEnB,ICSM0B,IAAMA,CAACC,IAAiBrB,IAAiBsB,OAAAA;AAC7C,MATuB,eAAA,OAAZC,WAAAA,CAA2BA,QAAQC,OACK,WAA1CD,QAAQC,IAAIC,0BAQD;AAEpB,QACMC,KAAS,KADG,oBAAIxB,QAAOyB,YAAAA,CAAAA;AAE7B,UAAQN,IAAAA;IACN,KAAK;AACHO,cAAQR,IAAIM,IAAQ1B,IAASsB,MAAQ,EAAA;AACrC;IACF,KAAK;AACHM,cAAQC,KAAKH,IAAQ1B,IAASsB,MAAQ,EAAA;AACtC;IACF,KAAK;AACHM,cAAQE,MAAMJ,IAAQ1B,IAASsB,MAAQ,EAAA;EAAA;AAAA;ADtB7C,IC2BaS,IACF,EACPC,SAAUC,CAAAA,OAAiBb,EAAI,QAAQ,oBAAoBa,EAAAA,GAC3DC,QAASD,CAAAA,OAAiBb,EAAI,QAAQ,mBAAmBa,EAAAA,EAAAA;AD9B7D,IC2BaF,IAKF,EACPI,MAAOnC,CAAAA,OAAiBoB,EAAI,QAAQ,iBAAiBpB,EAAAA,GACrDoC,UAAWpC,CAAAA,OAAiBoB,EAAI,QAAQ,qBAAqBpB,EAAAA,GAC7DqC,SAAUC,CAAAA,OAAsBlB,EAAI,QAAQ,oBAAoBkB,EAAAA,GAChEC,SAAUD,CAAAA,OAAsBlB,EAAI,QAAQ,oBAAoBkB,EAAAA,GAChEE,WAAYF,CAAAA,OAAsBlB,EAAI,QAAQ,8BAA8BkB,EAAAA,GAC5EG,gBAAgBA,MAAMrB,EAAI,QAAQ,2BAAA,GAClCsB,oBAAoBA,MAAMtB,EAAI,QAAQ,+BAAA,GACtCuB,SAAUC,CAAAA,OACRxB,EAAI,QAAQ,uCAAuCwB,EAAAA,EAAAA;ADzCzD,IC2Bab,IAgBL,EACJc,YAAYA,MAAMzB,EAAI,QAAQ,0CAAA,EAAA;AD5ClC,IC2BaW,IAmBF,EACPe,SAASA,MAAM1B,EAAI,QAAQ,iBAAA,GAC3B2B,WAAYC,CAAAA,OAAyB5B,EAAI,QAAQ,sBAAsB4B,EAAAA,EAAAA;ADhD3E,IC2BajB,IAuBHkB,CAAAA,OAAAA;AAON,QAAA,EAAMC,QAAEA,IAAMnC,aAAEA,IAAWV,MAAEA,IAAIX,QAAEA,IAAMyD,eAAEA,GAAAA,IAAkBF;AAE7D,MAAIjD,KAAU,GAAGkD,EAAAA;AAIjB,MAHInC,OAAaf,MAAW,eAAee,EAAAA,KACvCV,OAAML,MAAW,YAAYK,EAAAA,KAC7BX,OAAQM,MAAW,cAAcN,EAAAA,KACjCyD,cAAyBC,MAC3BpD,CAAAA,MAAW,aAAamD,GAAcnD,OAAAA;WACJ,YAAA,OAAlBmD,GAChBnD,CAAAA,MAAW,aAAamD,EAAAA;WACE,QAAjBA,GACT,KAAA;AACEnD,IAAAA,MAAW,aAAaqD,KAAKC,UAAUH,EAAAA,CAAAA;EACxC,SAACzC,IAAAA;AACAV,IAAAA,MAAW;EACb;AAGFoB,IAAI,SAAS,UAAUpB,EAAAA;AAAAA;AD3E3B,IEoBMuD,IACiB;AFrBvB,IEoBMA,IAEE;AFtBR,IEoBMA,IAGE;AAGR,IAAIC;AACJ,IAA6B,MAC3B,KAAA;AAEEA,MAAcC,KAAqBC;AACpC,SAAChD,IAAAA;AACA;AAcG,IAAMiD,IAAsBA,CACjC5C,IACAR,KAA4B,CAAA,MAAA;AAE5B,QAAA,EAAMqD,YACJA,IAAUC,kBACVA,KAAmB,KAAIC,mBACvBA,KAAAA,OAAyBC,iBACzBA,KAAkB,CAAA,GAAE/C,WACpBA,KAAY,IAAEgD,kBACdA,KAAmB,KAAaC,mBAChCA,KAAoB,GAACC,iBACrBA,KAAkB,IAAEC,2BACpBA,IAA4B,CAAA,EAAA,IAC1B5D,IAAAA,CAGG6D,GAAUC,CAAAA,QAAeC,aAAAA,UAA6B,CAAA,CAAA,GAAA,CACtDC,GAAcC,CAAAA,QAAmBF,aAAAA,UAA6B,CAAA,CAAA,GAAA,CAC9DxC,GAAO2C,CAAAA,QAAYH,aAAAA,UAAwB,IAAA,GAAA,CAC3CI,GAAkBC,CAAAA,QAAuBL,aAAAA,UAAAA,KAAS,GAGnDM,QAAUC,aAAAA,QAAgC,IAAA,GAC1CC,QAAqBD,aAAAA,QAAO,oBAAIE,KAAAA,GAChCC,QAAyBH,aAAAA,QAA2B,IAAA,GACpDI,QAAqBJ,aAAAA,QAA8B,IAAA,GACnDK,QAAsBL,aAAAA,QAA2B,CAAA,CAAA,GACjDM,QAAmBN,aAAAA,QAAAA,KAAO,GAG1BnF,QAAS0F,aAAAA,SAAQ,MAAMxB,MFtES,OAAOxE,EAAAA,CAAAA,IEsEoB,CAACwE,EAAAA,CAAAA,GAC5DyB,QAAgBD,aAAAA,SACpB,OAAO,EACLE,qBAAqBzE,EACnB0C,GACAxC,IACAC,EAAAA,GAEFuE,MAAM1E,EAAuB0C,GAA6BxC,IAAaC,EAAAA,GACvEwE,MAAM3E,EAAuB0C,GAA6BxC,IAAaC,EAAAA,EAAAA,IAEzE,CAACD,IAAaC,EAAAA,CAAAA,GAGVyE,QAAsBL,aAAAA,SAAQ,MAE3BpE,KAAY,GAAGD,EAAAA,IAAeC,EAAAA,KAAcD,IAClD,CAACA,IAAaC,EAAAA,CAAAA,GAEX0E,QAAwBN,aAAAA,SAAQ,MAAMrB,IAAiB,CAACV,KAAKC,UAAUS,EAAAA,CAAAA,CAAAA,GAEvE4B,QAAiBC,aAAAA,aAAY,MAAA;AACjCvB,MAAYwB,CAAAA,OAAQA,GAAKC,OAAOC,CAAAA,OAAAA,CAAQhG,EAAiBgG,EAAAA,CAAAA,CAAAA;EAAAA,GACxD,CAAA,CAAA,GAEGC,QAAmBnB,aAAAA,QAIvBZ,KAAoB,KFpCAgC,CACtBC,IACAC,OAAAA;AAKA,QAEIC,IAFAC,KAAkD,MAClDC,KAAiC;AAGrC,UAAMC,KAAYA,IAAIC,OAAAA;AACpBF,MAAAA,KAAWE,IACO,SAAdH,MACFI,aAAaJ,EAAAA,GAEfA,KAAYK,WAAW,MAAA;AACrBL,QAAAA,KAAY,MACK,SAAbC,OACFF,KAASF,GAAAA,GAAMI,EAAAA,GACfA,KAAW;MAAA,GAEZH,EAAAA;IAAAA;AAuBL,WApBAI,GAAUI,SAAS,MAAA;AACC,eAAdN,OACFI,aAAaJ,EAAAA,GACbA,KAAY,MACZC,KAAW;IAAA,GAIfC,GAAUK,QAAQ,OACE,SAAdP,OACFI,aAAaJ,EAAAA,GACbA,KAAY,MACK,SAAbC,OACFF,KAASF,GAAAA,GAAMI,EAAAA,GACfA,KAAW,QAGRF,KAGFG;EAAAA,GERQZ,GAAgB1B,EAAAA,IACzB4C,OAAOC,OAAOnB,GAAgB,EAAEgB,QAAQA,MAAAA;EAAAA,EAAAA,CAAAA,CAAAA,EAC5CI,SAEIC,QAAkBpB,aAAAA,aAAa9D,CAAAA,OAAAA;AACnC2C,MAAS3C,EAAAA,GACT4E,WAAW,MAAMjC,EAAS,IAAA,GAAO,GAAA;EAAA,GAChC,CAAA,CAAA,GAEGwC,QAAOrB,aAAAA,aACX,CAACsB,KAAoB,QAAA;AACnB,QAAIxC,EAEF,QADA3C,EAAWc,WAAAA,GACJsE,QAAQC,QAAQ,CAAA,CAAA;AAGzB,QAAA,CAAKxC,EAAQmC,SAAS;AACpB,YAAMjF,KACJ;AAOF,aANAC,EAAY,EACVmB,QAAQ,QACRnC,aAAa0E,GACbtC,eAAerB,GAAAA,CAAAA,GAEjBkF,EAAgBlF,EAAAA,GACTqF,QAAQC,QAAQ,CAAA,CAAA;IACzB;AAGI5D,QACFA,EAAY,MAAMmB,EAAAA,IAAoB,CAAA,IAEtCA,EAAAA,IAAoB;AAEtB,UAAM0C,KAAY,oBAAIC;AAKtB,WAJAtC,EAAuB+B,UAAUM,IAEjCzC,EAAQmC,QAAQQ,YAAYnH,EAAciF,EAAcE,MAAM,MAAM7F,CAAAA,CAAAA,GAE7D,IAAIyH,QAAQC,CAAAA,OAAAA;AACjBV,iBAAW,MAAA;AACT/B,UAAAA,KAAoB,GAChBK,EAAuB+B,YAAYM,OACrCrC,EAAuB+B,UAAU,OAEnCK,GAAQI,MAAMC,KAAKJ,EAAAA,CAAAA;MAAAA,GAClBH,EAAAA;IAAAA,CAAAA;EAAAA,GAGP,CAAC7B,EAAcE,MAAM7F,GAAQsH,GAAiBtC,GAAkBlB,CAAAA,CAAAA,GAG5D+D,QAAc3B,aAAAA,aAClB,CAAChD,IAAqB8E,IAAqBnH,KAA8B,CAAA,MAAA;AACvE,UAAMoH,KAAiB/C,EAAQmC;AAC/B,QAAA,CAAKY,IAAgB;AACnB,YAAM7F,KACJ;AAQF,aAPAC,EAAY,EACVmB,QAAQ,eACRnC,aAAa0E,GACbpF,MAAMuC,IACNO,eAAerB,GAAAA,CAAAA,GAAAA,KAEjBkF,EAAgBlF,EAAAA;IAElB;AAEA,UAAM9B,KAAUI,EAAcwC,IAAa8E,IAAgBhI,GAAQa,EAAAA;AAInE,QAAA,CADG2D,MAAmBA,KAAkB,KAAKC,EAA0ByD,SAAShF,EAAAA,EAE9E,KAAA;AACE+E,MAAAA,GAAeJ,YAAYvH,EAAAA;IAC5B,SAAQ6H,IAAAA;AACP,YAAM/F,KAAQ;AACdC,QAAY,EACVmB,QAAQ,eACRnC,aAAa0E,GACbpF,MAAMuC,IACNO,eAAerB,GAAAA,CAAAA,GAEjBkF,EAAgBlF,EAAAA,GAChBqD,EAAiB4B,UAAAA;IACnB;QAEA7B,GAAoB6B,QAAQe,KAAK9H,EAAAA,GAC5BiF,EAAmB8B,YACtB9B,EAAmB8B,UAAUL,WAAW,MAAA;AACtC,UAAIvB,EAAiB4B,QAGnB,QAFA7B,EAAoB6B,UAAU,CAAA,GAAA,MAC9B9B,EAAmB8B,UAAU;AAG/B,UAAA;AACEY,QAAAA,GAAeJ,YAAYrC,EAAoB6B,OAAAA;MAChD,SAAQc,IAAAA;AACP,cAAM/F,KAAQ;AACdC,UAAY,EACVmB,QAAQ,eACRnC,aAAa0E,GACbpF,MAAMuC,IACNO,eAAerB,GAAAA,CAAAA,GAEjBkF,EAAgBlF,EAAAA,GAChBqD,EAAiB4B,UAAAA;MACnB;AACA7B,QAAoB6B,UAAU,CAAA,GAC9B9B,EAAmB8B,UAAU;IAAA,GAC5B7C,EAAAA;AAGPnC,MAAcI,KAAKnC,EAAAA,GACnBwE,EAAgBqB,CAAAA,OAAQ,CAAA,GAAIA,IAAM7F,EAAAA,CAAAA;EAAAA,GAEpC,CAACN,GAAQsH,GAAiB9C,IAAiBC,CAAAA,CAAAA,GAGvC4D,QAAwBnC,aAAAA,aAAY,CAACrF,KAAwC,CAAA,MAAA;AACjF,UAAMyH,KAAaC,QAChB1H,GAAQ2H,OAAO3H,GAAQ2H,IAAIC,UACzB5H,GAAQ6H,SAAS7H,GAAQ6H,MAAMD,UAC/B5H,GAAQ8H,WAAW9H,GAAQ8H,QAAQF,MAAAA;AAGxC9D,MAAYwB,CAAAA,OACVmC,KACInC,GAAKC,OACHC,CAAAA,OAAAA,EACIxF,GAAQ2H,OAAO3H,GAAQ2H,IAAIN,SAAS7B,GAAItF,EAAAA,KACxCF,GAAQ6H,SAAS7H,GAAQ6H,MAAMR,SAAS7B,GAAI1F,IAAAA,KAC5CE,GAAQ8H,WAAW9H,GAAQ8H,QAAQT,SAAS7B,GAAIrG,MAAAA,EAAAA,IAEtD,CAAA,CAAA,GAEDsI,MACHjG,EAAcW,mBAAAA;EAAAA,GAEf,CAAA,CAAA,GAEG4F,SAAoB1C,aAAAA,aAAY,CAACrF,KAAoC,CAAA,MAAA;AAAA,QAAAgI,IAAAC,IAAAC;AACzE,UAAA,EAAMP,KAAEA,KAAM,CAAA,GAAEE,OAAEA,KAAQ,CAAA,GAAEM,MAAEA,KAAAA,MAAO,IAAUnI,QAAAA,KAAAA,KAAW,CAAE;AAC5DiE,MAAgBqB,CAAAA,OACdqC,GAAIC,SAAS,KAAKC,GAAMD,SAAS,IAC7BtC,GAAKC,OAAOC,CAAAA,OAAAA;AAEV,UAAIA,GAAIrG,WAAWA,EAAQ,QAAA;AAK3B,YAAMiJ,KAA2B,MAAfT,GAAIC,UAAgBD,GAAIN,SAAS7B,GAAItF,EAAAA,GACjDmI,KAA+B,MAAjBR,GAAMD,UAAgBC,GAAMR,SAAS7B,GAAI1F,IAAAA;AAG7D,aAAA,EAASsI,MAAaC;IAAAA,CAAAA,IAExB,CAAA,CAAA,GAEa,MAAfV,GAAIC,UAAiC,MAAjBC,GAAMD,UAC5BpG,EAAcU,eAAAA,GAEZiG,OACa,UAAfhI,KAAAkE,EAAQmC,YAAAA,WAAOrG,MAAAA,GAAE6G,YACfnH,EACEiF,EAAcC,qBACd,EAAE4C,KAAAA,UAAKW,KAAAtI,GAAQ2H,QAAAA,WAAAA,KAAAA,KAAO,CAAA,GAAIE,OAAoB,UAAAK,KAAblI,GAAQ6H,UAAAA,WAAKU,KAAAA,KAAI,CAAA,EAAA,GAClDpJ,CAAAA,CAAAA;EAAAA,GAIL,CAAA,CAAA,GAEGqJ,SAAmBnD,aAAAA,aACvB,CAACrF,KAAmC,CAAA,MAAA;AAClC,UAAA,EAAMb,QAAEA,IAAMW,MAAEA,GAAAA,IAASE;AAEzB,aAASyI,KAAI5E,EAAS+D,SAAS,GAAGa,MAAK,GAAGA,MAAK;AAC7C,YAAMjD,KAAM3B,EAAS4E,EAAAA,GACfC,KAAAA,CAAiBvJ,MAAUqG,GAAIrG,WAAWA,IAC1CkJ,KAAAA,CAAevI,MAAQ0F,GAAI1F,SAASA;AAC1C,UAAI4I,MAAiBL,GACnB,QAAO7C;IAEX;AAEA,WAAO;EAAA,GAET,CAAC3B,CAAAA,CAAAA,GAGG8E,SAAgBtD,aAAAA,aACnBuD,CAAAA,OAAAA;AAAAA,QAAAA;AACC,QAAA;AACE,YAAMnJ,KAA4BmJ,GAAM7H;AAGxC,UAFAS,EAAcK,SAASpC,EAAAA,GAAAA,EF/RAA,CAAAA,OACtBiI,QAAQjI,MAA8B,YAAA,OAAZA,MAAwB,QAAQA,EAAAA,GEgSvCA,EAAAA,EAAU;AAC9B,UAAIA,GAAQN,WAAWA,EAAQ;AAC/B,UAAIwB,EAA4BlB,EAAAA,GAAU;AACxC,YAAIA,GAAQK,SAASgF,EAAcC,qBAAqB;AACtD,gBAAA,EAAM4C,KAAEA,KAAM,CAAA,GAAEE,OAAEA,KAAQ,CAAA,EAAA,IAAQpI,GAAgBA,WAAW,CAAE;AAiB/D,iBAAA,KAfAqE,EAAYwB,CAAAA,OAAQ,CAAA,GACfA,GAAKC,OAAOC,CAAAA,OAAAA;AAEb,gBAAIA,GAAIrG,WAAWM,GAAQN,OAAQ,QAAA;AAKnC,kBAAMiJ,KAA2B,MAAfT,GAAIC,UAAgBD,GAAIN,SAAS7B,GAAItF,EAAAA,GACjDmI,KAA+B,MAAjBR,GAAMD,UAAgBC,GAAMR,SAAS7B,GAAI1F,IAAAA;AAE7D,mBAAA,EAASsI,MAAaC;UAAAA,CAAAA,CAAAA,CAAAA;QAK5B;AACA,YAAI5I,GAAQK,SAASgF,EAAcE,KAEjC,QAAA,MADiB,UAAjB7E,KAAAkE,EAAQmC,YAAAA,WAASrG,MAAAA,GAAA6G,YAAYnH,EAAciF,EAAcG,MAAM,MAAM9F,CAAAA,CAAAA;AAIvE,YAAIM,GAAQK,SAASgF,EAAcG,MAAM;AACvC,gBAAM4D,KAAapJ,GAAQN,QACrB2H,KAAYrC,EAAuB+B;AAMzC,iBAAA,MAJIM,MAAAA,UAAaA,GAAUgC,IAAID,EAAAA,KAC7B/B,GAAUiC,IAAIF,EAAAA;QAIlB;MACF;AACA,UAAI1D,EAAsByC,SAAS,KAAA,CAAMzC,EAAsBkC,SAAS5H,GAAQK,IAAAA,EAE9E,QAAA,KADA0B,EAAcY,QAAQ3C,GAAQK,IAAAA;AAGhC,UAAIN,EAAiBC,EAAAA,EAEnB,QAAA,KADA+B,EAAcQ,QAAQvC,GAAQS,EAAAA;AAIhC,YAAMN,KAAMD,KAAKC,IAAAA,GACXoJ,KAAazE,EAAmBiC,QAAQyC,IAAIxJ,GAAQS,EAAAA;AAC1D,UAAI8I,MAAcpJ,KAAMoJ,KAAavF,GAEnC,QAAA,KADAjC,EAAcS,UAAUxC,GAAQS,EAAAA;AAIlCqE,QAAmBiC,QAAQ0C,IAAIzJ,GAAQS,IAAIN,EAAAA,GAC3CkE,EAAYwB,CAAAA,OAAS/B,KAAoB,CAAC9D,EAAAA,IAAW,CAAA,GAAI6F,IAAM7F,EAAAA,CAAAA;IAChE,SAAQ6H,IAAAA;AACP,YAAM/F,KAAQ;AACdC,QAAY,EACVmB,QAAQ,iBACRnC,aAAa0E,GACbtC,eAAerB,GAAAA,CAAAA,GAEjBkF,EAAgBlF,EAAAA;IAClB;EAAA,GAEF,CACEpC,GACAgG,GACA5B,IACAkD,GACA3B,GACArB,EAAAA,CAAAA,GAIE0F,SAAe9D,aAAAA,aAAY,MAAA;AAC/B,UAAM+D,KAAK/E,EAAQmC;AACf4C,IAAAA,MAA0B,cAAA,OAAbA,GAAGC,UAClBD,GAAGE,oBAAoB,WAAWX,EAAAA,GAClCS,GAAGC,MAAAA,GACH7H,EAAcG,OAAOuD,CAAAA,GACrBb,EAAQmC,UAAU;EAAA,GAEnB,CAACmC,IAAezD,CAAAA,CAAAA;AAyGnB,aAvGAqE,aAAAA,WAAU,MAAA;AACR,QAAgC,eAAA,OAArBC,kBAAkC;AAC3C,YAAMjI,KACJ;AAOF,aANAC,EAAY,EACVmB,QAAQ,uBACRnC,aAAa0E,GACbtC,eAAerB,GAAAA,CAAAA,GAAAA,KAEjBkF,EAAgBlF,EAAAA;IAElB;AAEA,QAAI6H,KAA8B;AAClC,QAAA;AACEA,MAAAA,KAAK,IAAII,iBAAiBtE,CAAAA;IAC3B,SAAQoC,IAAAA;AACP,YAAM/F,KAAQ;AAOd,aANAC,EAAY,EACVmB,QAAQ,uBACRnC,aAAa0E,GACbtC,eAAe0E,cAAazE,QAAQyE,KAAImC,OAAOnC,EAAAA,EAAAA,CAAAA,GAAAA,KAEjDb,EAAgBlF,EAAAA;IAElB;AAcA,WAbA8C,EAAQmC,UAAU4C,IAClB5H,EAAcC,QAAQyD,CAAAA,GAEtBkE,GAAGM,iBAAiB,WAAYd,CAAAA,OAAAA;AAE1B3B,YAAM0C,QAAQf,GAAM7H,IAAAA,IACtB6H,GAAM7H,KAAK6I,QAASnK,CAAAA,OAAAA;AAClBkJ,WAAc,EAAE5H,MAAMtB,GAAAA,CAAAA;MAAAA,CAAAA,IAGxBkJ,GAAcC,EAAAA;IAAAA,CAAAA,GAGX,MAAA;AACLO,SAAAA;IAAAA;EAAAA,GAED,CAACjE,GAAqByD,IAAelC,CAAAA,CAAAA,OAExC8C,aAAAA,WAAU,MAAA;AACR,QAAIjG,MAAoB,EAAG;AAE3B,UAAMuG,KAAWC,YAAY,MAAA;AAC3BtI,QAAce,QAAAA;AACd,YAAMwH,KAASlG,EAAS+D;AACxBnC,QAAAA,GACAjE,EAAcgB,UAAUuH,KAASlG,EAAS+D,MAAAA;IAAAA,GACzCtE,EAAAA;AAEH,WAAO,MAAA;AAAA,UAAA0E;AACLgC,oBAAcH,EAAAA,GAEVnG,KAAoB,MACC,UAAvBvD,KAAAsF,EAAiBW,WAAAA,WAAMjG,MAAAA,GAAA8J,KAAAxE,CAAAA;IAAAA;EAAAA,GAG1B,CAACnC,IAAkBmC,GAAkB/B,EAAAA,CAAAA,OAExC6F,aAAAA,WAAU,MAAA;AACR,UAAMM,KAAWC,YAAY,MAAA;AAC3B,YAAMlK,KAAMD,KAAKC,IAAAA;AACjB,iBAAK,CAAOsK,IAAK9K,EAAAA,KAAcmF,EAAmBiC,QAAQ2D,QAAAA,EACpDvK,CAAAA,KAAMR,MAAaqE,MACrBc,EAAmBiC,QAAQ4D,OAAOF,EAAAA;IAAAA,GAGrC,GAAA;AAEH,WAAO,MAAMF,cAAcH,EAAAA;EAAAA,GAC1B,CAACpG,EAAAA,CAAAA,OAEJ8F,aAAAA,WAAU,MACD,MAAA;AAEL,QAAI5E,EAAoB6B,QAAQoB,SAAS,KAAKvD,EAAQmC,WAAAA,CAAY5B,EAAiB4B,SAAS;AAC1F,UAAA;AACEnC,UAAQmC,QAAQQ,YAAYrC,EAAoB6B,OAAAA;MACjD,SAAQc,IAAAA;AACP,cAAM/F,KAAQ;AACdC,UAAY,EACVmB,QAAQ,uBACRnC,aAAa0E,GACbtC,eAAe0E,cAAazE,QAAQyE,KAAImC,OAAOnC,EAAAA,EAAAA,CAAAA,GAEjDb,EAAgBlF,EAAAA;MAClB;AACAoD,QAAoB6B,UAAU,CAAA,GAE9BL,WAAW,MAAA;MAAA,GAAU,CAAA;IACvB;AACIzB,MAAmB8B,YACrBN,aAAaxB,EAAmB8B,OAAAA,GAChC9B,EAAmB8B,UAAU,OAE/B5B,EAAiB4B,UAAAA;EAAU,GAE5B,CAAA,CAAA,GAEI,EACLhG,aAAa0E,GACbrB,UAAAA,GACAG,cAAAA,GACAG,kBAAAA,GACAuC,MAAAA,GACAM,aAAAA,GACAQ,uBAAAA,GACAO,mBAAAA,IACAS,kBAAAA,IACAjH,OAAAA,GACA4H,cAAAA,GAAAA;AAAAA;AA5cG,IC5CDkB,QAA0BC,aAAAA,eAAAA,MAA4CjK;AD4CrE,ICrCMkK,IAAsDA,CAAAA,EAAGC,UAAAA,IAAUhK,aAAAA,GAAAA,MAAAA;AAC9E,QAAMiK,KAA0BrH,EAAoB5C,EAAAA;AAEpD,aACEkK,mBAAAA,KAACL,EAAwBM,UAAQ,EAACC,OAAOH,IAAuBD,UAC7DA,GAAAA,CAAAA;AAAAA;ADgCA,IC3BMK,IAAuBA,MAAAA;AAClC,QAAMnI,SAAUoI,aAAAA,YAAWT,CAAAA;AAC3B,MAAA,CAAK3H,GACH,OAAM,IAAIG,MAAM,8DAAA;AAElB,SAAOH;AAAAA;",
  "names": ["INTERNAL_PREFIX", "generateRandomPart", "Math", "random", "toString", "substr", "generateMessageId", "source", "timestamp", "raw", "btoa", "replace", "isMessageExpired", "message", "expirationDate", "Date", "now", "createMessage", "type", "content", "options", "s", "id", "_a", "expirationDuration", "undefined", "getInternalMessageType", "baseType", "channelName", "namespace", "hash", "isValidInternalClearMessage", "startsWith", "log", "level", "data", "process", "env", "REACT_APP_DEBUG_BROADCAST", "prefix", "toISOString", "console", "warn", "error", "debug", "created", "name", "closed", "sent", "received", "cleared", "messageId", "expired", "duplicate", "allSentCleared", "allReceivedCleared", "ignored", "messageType", "inProgress", "started", "completed", "removedCount", "context", "action", "originalError", "Error", "JSON", "stringify", "INTERNAL_MESSAGE_TYPES", "flushSyncFn", "require", "flushSync", "useBroadcastChannel", "sourceName", "cleaningInterval", "keepLatestMessage", "registeredTypes", "deduplicationTTL", "cleanupDebounceMs", "batchingDelayMs", "excludedBatchMessageTypes", "messages", "setMessages", "useState", "sentMessages", "setSentMessages", "setError", "isPingInProgress", "setIsPingInProgress", "channel", "useRef", "receivedMessageIds", "Map", "activeSourcesCollector", "batchingTimeoutRef", "batchingMessagesRef", "batchingErrorRef", "useMemo", "internalTypes", "CLEAR_SENT_MESSAGES", "PING", "PONG", "resolvedChannelName", "stableRegisteredTypes", "performCleanup", "useCallback", "prev", "filter", "msg", "debouncedCleanup", "debounce", "fn", "wait", "result", "timeoutId", "lastArgs", "debounced", "args", "clearTimeout", "setTimeout", "cancel", "flush", "Object", "assign", "current", "setErrorMessage", "ping", "timeoutMs", "Promise", "resolve", "collector", "Set", "postMessage", "Array", "from", "messageContent", "channelCurrent", "includes", "e", "push", "clearReceivedMessages", "hasFilters", "Boolean", "ids", "length", "types", "sources", "clearSentMessages", "r", "t", "n", "sync", "idMatches", "typeMatches", "_b", "_c", "getLatestMessage", "i", "sourceMatches", "handleMessage", "event", "pongSource", "has", "add", "receivedAt", "get", "set", "closeChannel", "bc", "close", "removeEventListener", "useEffect", "BroadcastChannel", "String", "addEventListener", "isArray", "forEach", "interval", "setInterval", "before", "clearInterval", "call", "key", "entries", "delete", "BroadcastChannelContext", "createContext", "BroadcastProvider", "children", "BroadcastChannelActions", "_jsx", "Provider", "value", "useBroadcastProvider", "useContext"]
}
