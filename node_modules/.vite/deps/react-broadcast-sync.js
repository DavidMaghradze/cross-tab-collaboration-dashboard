import {
  require_jsx_runtime
} from "./chunk-RLMGAKMB.js";
import {
  __toESM,
  require_react
} from "./chunk-2YIMICFJ.js";

// node_modules/react-broadcast-sync/dist/index.esm.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var i = "__INTERNAL__";
var l = () => Math.random().toString(36).substr(2, 9);
var u = (e2, r2) => {
  const t2 = `${l()}-${e2}-${r2}`;
  return btoa(t2).replace(/=+$/, "");
};
var d = (e2) => !!e2.expirationDate && e2.expirationDate < Date.now();
var p = (e2, r2, t2, n2 = {}) => {
  var s2;
  const a2 = Date.now();
  return { id: u(t2, a2), type: e2, message: r2, timestamp: a2, source: t2, expirationDate: null !== (s2 = n2.expirationDate) && void 0 !== s2 ? s2 : n2.expirationDuration ? a2 + n2.expirationDuration : void 0 };
};
var g = (e2, r2, t2 = "") => {
  const n2 = btoa(`react-broadcast-sync:${e2}:${`${r2}-${t2}`}`);
  return `${i}:${e2}:${n2}`;
};
var f = (e2) => e2 && "object" == typeof e2 && "string" == typeof e2.type && e2.type.startsWith(`${i}:`) && "string" == typeof e2.source;
var h = (e2, r2, t2) => {
  if ("undefined" == typeof process || !process.env || "true" !== process.env.REACT_APP_DEBUG_BROADCAST) return;
  const n2 = `[${(/* @__PURE__ */ new Date()).toISOString()}] [react-broadcast-sync]`;
  switch (e2) {
    case "info":
      console.log(n2, r2, t2 || "");
      break;
    case "warn":
      console.warn(n2, r2, t2 || "");
      break;
    case "error":
      console.error(n2, r2, t2 || "");
  }
};
var y = { created: (e2) => h("info", "Channel created:", e2), closed: (e2) => h("info", "Channel closed:", e2) };
var m = { sent: (e2) => h("info", "Message sent:", e2), received: (e2) => h("info", "Message received:", e2), cleared: (e2) => h("info", "Message cleared:", e2), expired: (e2) => h("info", "Message expired:", e2), duplicate: (e2) => h("warn", "Duplicate message ignored:", e2), allSentCleared: () => h("info", "All sent messages cleared"), allReceivedCleared: () => h("info", "All received messages cleared"), ignored: (e2) => h("info", "Message ignored due to type filter:", e2) };
var v = { inProgress: () => h("warn", "Ping already in progress. Skipping call.") };
var E = { started: () => h("info", "Cleanup started"), completed: (e2) => h("info", "Cleanup completed:", e2) };
var N = (e2) => {
  const { action: r2, channelName: t2, type: n2, source: s2, originalError: a2 } = e2;
  let o2 = `${r2}`;
  if (t2 && (o2 += ` | channel: ${t2}`), n2 && (o2 += ` | type: ${n2}`), s2 && (o2 += ` | source: ${s2}`), a2 instanceof Error) o2 += ` | cause: ${a2.message}`;
  else if ("string" == typeof a2) o2 += ` | cause: ${a2}`;
  else if (null != a2) try {
    o2 += ` | cause: ${JSON.stringify(a2)}`;
  } catch (e3) {
    o2 += " | cause: [unserializable]";
  }
  h("error", "Error:", o2);
};
var M = "CLEAR_SENT_MESSAGES";
var S = "PING";
var b = "PONG";
var P;
if (false) try {
  P = null.flushSync;
} catch (e2) {
}
var C = (a2, o2 = {}) => {
  const { sourceName: c2, cleaningInterval: i2 = 1e3, keepLatestMessage: u2 = false, registeredTypes: h2 = [], namespace: C2 = "", deduplicationTTL: w2 = 3e5, cleanupDebounceMs: $2 = 0, batchingDelayMs: T2 = 20, excludedBatchMessageTypes: A = [] } = o2, [D, B] = (0, import_react.useState)([]), [_, G] = (0, import_react.useState)([]), [I, x] = (0, import_react.useState)(null), [L, O] = (0, import_react.useState)(false), R = (0, import_react.useRef)(null), k = (0, import_react.useRef)(/* @__PURE__ */ new Map()), j = (0, import_react.useRef)(null), F = (0, import_react.useRef)(null), J = (0, import_react.useRef)([]), q = (0, import_react.useRef)(false), z = (0, import_react.useMemo)(() => c2 || `tab-${l()}`, [c2]), U = (0, import_react.useMemo)(() => ({ CLEAR_SENT_MESSAGES: g(M, a2, C2), PING: g(S, a2, C2), PONG: g(b, a2, C2) }), [a2, C2]), V = (0, import_react.useMemo)(() => C2 ? `${a2}-${C2}` : a2, [a2, C2]), W = (0, import_react.useMemo)(() => h2, [JSON.stringify(h2)]), H = (0, import_react.useCallback)(() => {
    B((e2) => e2.filter((e3) => !d(e3)));
  }, []), K = (0, import_react.useRef)($2 > 0 ? ((e2, r2) => {
    let t2, n2 = null, s2 = null;
    const a3 = (...a4) => {
      s2 = a4, null !== n2 && clearTimeout(n2), n2 = setTimeout(() => {
        n2 = null, null !== s2 && (t2 = e2(...s2), s2 = null);
      }, r2);
    };
    return a3.cancel = () => {
      null !== n2 && (clearTimeout(n2), n2 = null, s2 = null);
    }, a3.flush = () => (null !== n2 && (clearTimeout(n2), n2 = null, null !== s2 && (t2 = e2(...s2), s2 = null)), t2), a3;
  })(H, $2) : Object.assign(H, { cancel: () => {
  } })).current, Q = (0, import_react.useCallback)((e2) => {
    x(e2), setTimeout(() => x(null), 3e3);
  }, []), X = (0, import_react.useCallback)((e2 = 300) => {
    if (L) return v.inProgress(), Promise.resolve([]);
    if (!R.current) {
      const e3 = "BroadcastChannel is not supported in this browser. Please check browser compatibility.";
      return N({ action: "ping", channelName: V, originalError: e3 }), Q(e3), Promise.resolve([]);
    }
    P ? P(() => O(true)) : O(true);
    const r2 = /* @__PURE__ */ new Set();
    return j.current = r2, R.current.postMessage(p(U.PING, null, z)), new Promise((t2) => {
      setTimeout(() => {
        O(false), j.current === r2 && (j.current = null), t2(Array.from(r2));
      }, e2);
    });
  }, [U.PING, z, Q, L, P]), Y = (0, import_react.useCallback)((e2, r2, t2 = {}) => {
    const n2 = R.current;
    if (!n2) {
      const r3 = "BroadcastChannel is not supported in this browser. Please check browser compatibility.";
      return N({ action: "postMessage", channelName: V, type: e2, originalError: r3 }), void Q(r3);
    }
    const s2 = p(e2, r2, z, t2);
    if (!T2 || T2 < 0 || A.includes(e2)) try {
      n2.postMessage(s2);
    } catch (r3) {
      const t3 = "Failed to send message";
      N({ action: "postMessage", channelName: V, type: e2, originalError: t3 }), Q(t3), q.current = true;
    }
    else J.current.push(s2), F.current || (F.current = setTimeout(() => {
      if (q.current) return J.current = [], void (F.current = null);
      try {
        n2.postMessage(J.current);
      } catch (r3) {
        const t3 = "Failed to send message";
        N({ action: "postMessage", channelName: V, type: e2, originalError: t3 }), Q(t3), q.current = true;
      }
      J.current = [], F.current = null;
    }, T2));
    m.sent(s2), G((e3) => [...e3, s2]);
  }, [z, Q, T2, A]), Z = (0, import_react.useCallback)((e2 = {}) => {
    const r2 = Boolean(e2.ids && e2.ids.length || e2.types && e2.types.length || e2.sources && e2.sources.length);
    B((t2) => r2 ? t2.filter((r3) => !(e2.ids && e2.ids.includes(r3.id) || e2.types && e2.types.includes(r3.type) || e2.sources && e2.sources.includes(r3.source))) : []), r2 || m.allReceivedCleared();
  }, []), ee = (0, import_react.useCallback)((e2 = {}) => {
    var r2, t2, n2;
    const { ids: s2 = [], types: a3 = [], sync: o3 = false } = null != e2 ? e2 : {};
    G((e3) => s2.length > 0 || a3.length > 0 ? e3.filter((e4) => {
      if (e4.source !== z) return true;
      const r3 = 0 === s2.length || s2.includes(e4.id), t3 = 0 === a3.length || a3.includes(e4.type);
      return !(r3 && t3);
    }) : []), 0 === s2.length && 0 === a3.length && m.allSentCleared(), o3 && (null === (r2 = R.current) || void 0 === r2 || r2.postMessage(p(U.CLEAR_SENT_MESSAGES, { ids: null !== (t2 = e2.ids) && void 0 !== t2 ? t2 : [], types: null !== (n2 = e2.types) && void 0 !== n2 ? n2 : [] }, z)));
  }, []), re = (0, import_react.useCallback)((e2 = {}) => {
    const { source: r2, type: t2 } = e2;
    for (let e3 = D.length - 1; e3 >= 0; e3--) {
      const n2 = D[e3], s2 = !r2 || n2.source === r2, a3 = !t2 || n2.type === t2;
      if (s2 && a3) return n2;
    }
    return null;
  }, [D]), te = (0, import_react.useCallback)((e2) => {
    var r2;
    try {
      const t2 = e2.data;
      if (m.received(t2), !((e3) => Boolean(e3 && "object" == typeof e3 && "id" in e3))(t2)) return;
      if (t2.source === z) return;
      if (f(t2)) {
        if (t2.type === U.CLEAR_SENT_MESSAGES) {
          const { ids: e3 = [], types: r3 = [] } = t2.message || {};
          return void B((n3) => [...n3.filter((n4) => {
            if (n4.source !== t2.source) return true;
            const s3 = 0 === e3.length || e3.includes(n4.id), a3 = 0 === r3.length || r3.includes(n4.type);
            return !(s3 && a3);
          })]);
        }
        if (t2.type === U.PING) return void (null === (r2 = R.current) || void 0 === r2 || r2.postMessage(p(U.PONG, null, z)));
        if (t2.type === U.PONG) {
          const e3 = t2.source, r3 = j.current;
          return void (r3 && false === r3.has(e3) && r3.add(e3));
        }
      }
      if (W.length > 0 && !W.includes(t2.type)) return void m.ignored(t2.type);
      if (d(t2)) return void m.expired(t2.id);
      const n2 = Date.now(), s2 = k.current.get(t2.id);
      if (s2 && n2 - s2 < w2) return void m.duplicate(t2.id);
      k.current.set(t2.id, n2), B((e3) => u2 ? [t2] : [...e3, t2]);
    } catch (e3) {
      const r3 = "Error processing broadcast message";
      N({ action: "handleMessage", channelName: V, originalError: r3 }), Q(r3);
    }
  }, [z, W, u2, Q, U, w2]), ne = (0, import_react.useCallback)(() => {
    const e2 = R.current;
    e2 && "function" == typeof e2.close && (e2.removeEventListener("message", te), e2.close(), y.closed(V), R.current = null);
  }, [te, V]);
  return (0, import_react.useEffect)(() => {
    if ("undefined" == typeof BroadcastChannel) {
      const e3 = "BroadcastChannel is not supported in this browser. Please check browser compatibility.";
      return N({ action: "useBroadcastChannel", channelName: V, originalError: e3 }), void Q(e3);
    }
    let e2 = null;
    try {
      e2 = new BroadcastChannel(V);
    } catch (e3) {
      const r2 = "Failed to create BroadcastChannel";
      return N({ action: "useBroadcastChannel", channelName: V, originalError: e3 instanceof Error ? e3 : String(e3) }), void Q(r2);
    }
    return R.current = e2, y.created(V), e2.addEventListener("message", (e3) => {
      Array.isArray(e3.data) ? e3.data.forEach((e4) => {
        te({ data: e4 });
      }) : te(e3);
    }), () => {
      ne();
    };
  }, [V, te, Q]), (0, import_react.useEffect)(() => {
    if (i2 <= 0) return;
    const e2 = setInterval(() => {
      E.started();
      const e3 = D.length;
      K(), E.completed(e3 - D.length);
    }, i2);
    return () => {
      var r2;
      clearInterval(e2), $2 > 0 && (null === (r2 = K.cancel) || void 0 === r2 || r2.call(K));
    };
  }, [i2, K, $2]), (0, import_react.useEffect)(() => {
    const e2 = setInterval(() => {
      const e3 = Date.now();
      for (const [r2, t2] of k.current.entries()) e3 - t2 >= w2 && k.current.delete(r2);
    }, 6e4);
    return () => clearInterval(e2);
  }, [w2]), (0, import_react.useEffect)(() => () => {
    if (J.current.length > 0 && R.current && !q.current) {
      try {
        R.current.postMessage(J.current);
      } catch (e2) {
        const r2 = "Failed to send message";
        N({ action: "useBroadcastChannel", channelName: V, originalError: e2 instanceof Error ? e2 : String(e2) }), Q(r2);
      }
      J.current = [], setTimeout(() => {
      }, 0);
    }
    F.current && (clearTimeout(F.current), F.current = null), q.current = false;
  }, []), { channelName: V, messages: D, sentMessages: _, isPingInProgress: L, ping: X, postMessage: Y, clearReceivedMessages: Z, clearSentMessages: ee, getLatestMessage: re, error: I, closeChannel: ne };
};
var w = (0, import_react.createContext)(void 0);
var $ = ({ children: e2, channelName: r2 }) => {
  const t2 = C(r2);
  return (0, import_jsx_runtime.jsx)(w.Provider, { value: t2, children: e2 });
};
var T = () => {
  const e2 = (0, import_react.useContext)(w);
  if (!e2) throw new Error("useBroadcastProvider must be used within a BroadcastProvider");
  return e2;
};
export {
  $ as BroadcastProvider,
  C as useBroadcastChannel,
  T as useBroadcastProvider
};
//# sourceMappingURL=react-broadcast-sync.js.map
